#!/usr/bin/python

import  pprint
import  sys

class   ovmCfg( object ):

    def __init__( self, file = sys.stdin, name = '<stdin>', out = sys.stdout ):
        self.fyle   = file
        self.fn     = name
        self.out    = out
        self.script = ''
        self.code   = None
        self.pp     = pprint.PrettyPrinter( indent=0 )
        self.keys   = None
        return

    def read( self ):
        try:
            for line in self.fyle:
                s = line.rstrip()
                self.script = self.script + line
        except:
            raise IOError
        return

    def compile( self ):
        try:
            self.code = compile( self.script, self.fn, 'exec' )
        except:
            raise SyntaxError
        self.locals = dict()
        globals = dict()
        try:
            eval( self.code, globals, self.locals )
        except:
            raise SyntaxError
        self.keys =  self.locals.keys()
        self.keys.sort()
        return

    def reconstruct( self, out = None ):
        if out == None:
            out = self.out
        l = 0
        inventory = []
        for key in self.keys:
            l = max( l, len(key) )
            inventory.append(key)
        inventory.sort( key = lambda s: s.lower() )
        fmt = '%%%ds =' % l
        for key in inventory:
            print >>out, fmt % key,
            s = self.pp.pformat( self.locals[key] )
            lines = s.split( '\n' )
            leadin = ''
            for line in lines:
                print >>out, '%s%s' % (leadin, line)
                leadin = ' '*(l+4)
        return

if __name__ == '__main__':
    import  optparse
    import  os
    import  sys

    p = optparse.OptionParser(
        description = """Display an Oracle VM configuration file in canonical form.
The output is sorted by keyword, then the printed using normal python indenting.
In an ideal world, the formatted output could be used to replace a poorly-edited
configuration file.""",
        usage = '%prog [-o ofile] [vm.cfg]',
        prog = os.path.basename( sys.argv[0] )
    )
    p.add_option(
        '-o',
        '--output',
        action='store',
        type='string',
        dest='ofile',
        help = 'Output written to file; defaults to stdout.'
    )
    p.set_defaults(
        ofile = None
    )
    opt, args = p.parse_args()
    o = sys.stdout
    if opt.ofile:
        try:
            os.unlink( opt.ofile )
        except:
            pass
        try:
            o = open( opt.ofile, 'wt' )
        except:
            print >>sys.stderr, 'Cannot open "%s" for writing.' % opt.ofile
            raise IOError
    if len(args) == 0:
        vmcfg = ovmCfg( out = o )
        vmcfg.read()
        vmcfg.compile()
        vmcfg.reconstruct()
    else:
        for arg in args:
            try:
                f = open( arg )
            except:
                raise IOError
            vmcfg = ovmCfg( file = f, out = o )
            vmcfg.read()
            vmcfg.compile()
            vmcfg.reconstruct()
    # The end..
